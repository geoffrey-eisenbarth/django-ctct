* Should User be done via subclassing Contact and creating a special version?
  * e.g. class Contact(Contact): user = models.OneToOneField()...
* ContactNote -> Note
  * timestamp -> created_at
  * note -> content

* Remove flat_notes



class TpgContact(Contact):

  * Contact.county, .address, .address_2, city, state, zip_code, -> StreetAddress
  * Contact.home_phone, office_phone, direct_phone, cell_phone -> PhoneNumber
  * Contact.fax -> ???
  * Contact.list -> list_memberships
  * Contact.optout -> opt_out, optout_at -> opt_out_date
  * Contact.phone @property removed
  * Contact.source ('www' / 'tpg') -> Contact.create_source ('Contact' / 'Account')
  * EmailCampaign.status -> .current_status


  # TODO: ACTUALLY...would it mess everything up if we set the 1-1 ON User? e.g.
  class User.contact = OneToOneField(Contact)?

  user = models.OneToOneField(
    settings.AUTH_USER_MODEL,
    on_delete=models.CASCADE,
    null=True,
    blank=True,
    related_name='contact',
  )


  def save(self, *args, **kwargs) -> None:
    if (
      (self.user is not None)
      and (self.email is not None)
      and (self.email != self.user.email)
    ):
      # Force user.email to agree with contact.email
      # TODO: This is because ProfileForm updates CONTACT, not USER
      # TODO: Split ProfileForm into Contact and User (email + pw change)
      # NOTE: This is assuming we want contact's email to mirrow USER's email
      #       as opposed to the other way around.
      self.user.email = self.email
      self.user.save(update_fields=['email'])

    if (not self.email) or (self._id and not self.lists.exists()):
      kwargs['save_to_ctct'] = False
    return super().save(*args, **kwargs)



  def __str__(self) -> str:
    if self.name and self.email:
      s = f'{self.name} ({self.email})'
    elif self.email:
      s = self.email
    elif self.name:
      s = self.name
    elif self.company_name and self.address:
      s = f'{self.company_name} ({self.address})'
    elif self.company_name:
      s = self.company_name
    else:
      s = 'N/A'
    return s

  def get_list(
    self,
    name: str = '',
    names: list = [],
  ) -> ContactList | None:
    if name:
      names = [name]
    contact_list = self.list_memberships.filter(name__in=names).first()
    return contact_list


  @cached_property
  def column(self) -> ContactList:
    return self.get_list('Column: Website')


  @cached_property
  def newsletter(self) -> ContactList:
    lists = [
      'Newsletter: Paid',
      'Newsletter: Comps',
      'Newsletter: Public Officials',
      'Legislators',
    ]
    return self.get_list(lists)

  @cached_property
  def forecast(self) -> ContactList:
    lists = ['Forecast: Major Texas Metros', 'Forecast: All Texas Regions']
    return self.get_list(lists)

  @cached_property
  def is_public_official(self) -> bool:
    lists = [
      'Public Officials',
      'Legislators',
    ]
    return bool(self.get_list(lists))

  @cached_property
  def is_media(self) -> bool:
    return self.lists.filter(name__startswith='Media').exists()

  @cached_property
  def is_newsletter(self) -> bool:
    return self.lists.filter(name__startswith='Newsletter').exists()

  @cached_property
  def is_comped(self) -> bool:
    return bool(self.get_list('Newsletter: Comps'))

  @cached_property
  def is_column(self) -> bool:
    return self.lists.filter(name__startswith='Column').exists()

  @cached_property
  def is_website(self) -> bool:
    return self.lists.filter(name__contains='Website').exists()



  # in serialize:
    if self.county:
      data['custom_fields'] = [{
        'custom_field_id': self.get_ctct_custom_field_id('county'),
        'value': self.county.name,
      }]
  #/end in serialize


class TpgNote(Note):
  author = models.ForeignKey(
    settings.AUTH_USER_MODEL,
    on_delete=models.CASCADE,
    limit_choices_to={'is_staff': True},
    editable=False,
  )

class TpgEmailCampaign(EmailCampaign):
  """Django implementation of a CTCT EmailCampaign.

  Notes
  -----
  We must be careful to NOT send Newsletters any other
  ContactList except for the 'Newsletter: Comps' list,
  since the default email contains a paywall URL.

  Instead, a copy of the EmailCampaign must be made in
  ConstantContact and the button URL changed to that of
  the hosted PDF (e.g., upload the PDF to "My Documents"
  using CTCT's website and then copy/paste the URL into
  BOTH buttons in the EmailCampaing (e.g., Outlook one
  and the regular one).

  """

  POST_CATEGORIES = {
    'COLUMN': [
      'Internal',
      'Column: Website',
      'Column: Office',
    ],
    'BRIEF': [
      'Internal',
      'Media',
      'Public Officials',
      'Column: Website',
      'Column: Office',
      'Newsletter: Paid',
      'Newsletter: Comps',
    ],
    'REPORT': [
      'Internal',
      'Media',
      'Public Officials',
      'Column: Website',
      'Column: Office',
      'Newsletter: Paid',
      'Newsletter: Comps',
    ],
    'PRESSRELEASE': [
      'Internal',
      'Media',
      'Public Officials',
      'Column: Website',
      'Column: Office',
      'Newsletter: Paid',
      'Newsletter: Comps',
    ],
    'NEWSLETTER': [
      # DO NOT SEND to "Newsletter: Comps", see Notes!
      'Internal',
      'Newsletter: Paid',
    ],
    'EMAIL': [],
  }


class TpgEmailCampaign()
  def _get_name(self) -> str:
    """Returns the CTCT EmailCampaign name."""

    category = 'DEBUG' if self.debug else self.post.category
    date = self.post.publish_date.strftime('%Y-%m-%d')
    if category == 'COLUMN':
      name = f'{category} {date}'
    elif category == 'NEWSLETTER':
      name = f'{category} {date} - PAID'
    else:
      name = f'{category} {date} {self.post.title}'

    if len(name) > 80:
      idx = (self.NAME_MAX_LENGTH - len('...')) // 2
      name = f'{name[:idx]}...{name[-idx:]}'

    return name


class TpgCampaignActivity():
  PREVIEW_CONTACTS = {
    'DEBUG': [
      ('Geoffrey Eisenbarth', 'geoffrey.eisenbarth@gmail.com'),
    ],
    'COLUMN': [
      ('Internal', 'info@perrymangroup.com'),
      ('Shelia Smith', 'sheliaws64@gmail.com'),
      ('Kevin Gleghorn', 'ckevingleghorn@gmail.com'),
      ('Geoffrey Eisenbarth', 'geoffrey.eisenbarth@gmail.com'),
    ],
    'RELEASE': [
      ('Internal', 'info@perrymangroup.com'),
      ('Ray Perryman', 'ray@perrymangroup.com'),
      ('Karen Amos', 'kamos@perrymangroup.com'),
      ('Ginnie Gleghorn', 'ginniegleghorn@gmail.com'),
      ('Geoffrey Eisenbarth', 'geoffrey.eisenbarth@gmail.com'),
    ],
  }

  def _get_preview_recipients(self) -> list:
    """Determines who receives the CTCT preview emails."""
    if self.campaign.debug:
      preview_list = 'DEBUG'
    elif self.campaign.post.category == 'COLUMN':
      preview_list = 'COLUMN'
    else:
      preview_list = 'RELEASE'
    return [email for (name, email) in self.PREVIEW_CONTACTS[preview_list]]

  @property
  def subject(self) -> str:
    """Returns the subject line based on the Post title."""
    if self.campaign.post.category == 'COLUMN':
      subject = f'Dr. Ray Perryman: "{self.campaign.post.title}"'
    elif self.campaign.post.category == 'EMAIL':
      subject = self.campaign.post.title
    else:
      subject = (
        f'{self.campaign.post.get_category_display()}: '
        f'{self.campaign.post.title}'
      )
    return subject

  @property
  def preheader(self) -> str:
    """Returns the email preheader based on the Post content."""
    preheader = (
      BeautifulSoup(self.campaign.post.content, features='lxml')
      .find('p')
      .text
      .split('.')[0]
      .replace('\r', '')
      .replace('\n', '')
    )
    return preheader

  @property
  def html_content(self) -> str:
    """Returns the email content as HTML."""

    html_content = render_to_string(
      template_name='accounts/ctct/post_email.html',
      context={
        'post': self.campaign.post,
        'base_url': f'http://www.{settings.PARENT_HOST}',
      },
    )
    return html_content

* admin.py
from django.db.models import Q, OuterRef, Exists
# Note: Must add this to ContactAdmin.list_filter
class ContactListGroupFilter(admin.SimpleListFilter):
  """Simple filter for CTCT Lists."""

  LISTS = (
    ('comped', _('Comped')),
    ('not_comped', _('Not Comped')),
    ('none', _('No Lists')),
    ('missing', _('Missing Email')),
    ('media', _('Any Media')),
    ('any', _('Any List')),
  )

  title = 'Contact List Group'
  parameter_name = 'list_group'

  def lookups(self, request, model_admin):
    return self.LISTS

  def queryset(self, request, queryset):

    if self.value() == 'comped':
      queryset = queryset.filter(list_memberships__name='Newsletter: Comps')
    elif self.value() == 'not_comped':
      queryset = queryset.exclude(list_memberships__name__in=[
        'Newsletter: Comps', 'Public Officials'
      ]).exclude(list_memberships__name__startswith='Media')
    elif self.value() == 'none':
      queryset = queryset.filter(list_memberships__isnull=True)
    elif self.value() == 'missing':
      queryset = queryset.filter(email=None)
    elif self.value() == 'media':
      ThroughModel = Contact.list_memberships.through
      condition = ThroughModel.objects.filter(
        contact=OuterRef('pk'),
        contactlist__name__startswith='Media',
      )
      queryset = queryset.filter(Exists(condition))
    elif self.value() == 'any':
      queryset = queryset.filter(list_memberships__isnull=False)

    return queryset

# admin.py
# Note must set form = ContactAdminForm in ContactAdmin
class ContactAdminForm(forms.ModelForm):
  """Custom form for Many2Many Validation."""

  class Meta:
    model = Contact
    fields = '__all__'

  def clean(self) -> None:
    """Verifies Many2Many relations."""

    # Validate ContactList membership
    list_memberships = self.cleaned_data.get('list_memberships')
    if not list_memberships:
      return super().clean()

    official = Q(name__contains='Public Officials') | Q(name='Legislators')
    media = Q(name__startswith='Media')
    column = Q(name__contains='Column')
    comped = Q(name='Newsletter: Comps')

    message = None
    if list_memberships.filter(official) and list_memberships.exclude(official | column):
      message = _(
        "Public Officials cannot be included in any other ContactLists."
      )
    elif list_memberships.filter(media) and list_memberships.exclude(media | column):
      message = _(
        "Media Contacts can only be included in other 'Media' ContactLists."
      )
    elif list_memberships.filter(comped) and list_memberships.filter(official | media):
      message = _(
        "Comped Contacts cannot be added to 'Public Officials' or 'Media' "
        "ContactLists."
      )

    if message is not None:
      raise ValidationError(message)

    return super().clean()


# admin.py
from django.contrib import admin, messages
from django.core.exceptions import ValidationError
from * import validate_contact_list_membership
class ContactAdmin(ExportActionMixin, admin.ModelAdmin):
  # TODO: Tpg specific
  actions = ['comp_contacts', 'uncomp_contacts']

  list_display = (
    [...]
    'lists',
  )

  search_fields = (
    #'state__postal_code',
    #'state__name',
  )
  
  # def county__name(self, obj) -> str:
  #   if obj.county is not None:
  #     name = obj.county.name
  #   else:
  #     name = ''
  #   return name
  # county__name.admin_order_field = 'county__name'
  # county__name.short_description = 'County'

  # def state__postal_code(self, obj) -> str:
  #   if obj.state is not None:
  #     postal_code = obj.state.postal_code
  #   else:
  #     postal_code = ''
  #   return postal_code
  # state__postal_code.admin_order_field = 'state'
  # state__postal_code.short_description = 'State'

  # TODO: TPG
  def list(self, obj) -> str:
    if (
      (obj.is_public_official and obj.is_comped)
      or (obj.is_media and obj.is_comped)
    ):
      text = 'Error'
      color = 'red'
    elif obj.is_public_official:
      text = 'Public Official'
      color = 'yellow'
    elif obj.is_media:
      text = 'Media'
      color = 'orange'
    elif obj.is_newsletter:
      text = 'Newsletter'
      color = 'purple'
    elif obj.is_column:
      text = 'Column'
      color = 'teal'
    elif not obj.list_memberships.exists():
      text = 'None'
      color = 'gold'
    else:
      text = 'Other'
      color = 'green'
    html = (
      f'<span class="badge {color}">'
      f'{text}'
      '</span>'
    )
    return mark_safe(html)

  def uncomp_contacts(self, request, queryset) -> None:
    """Removes Contacts from the Newsletter: Comp ContactList."""
    comp_list = ContactList.objects.get(name='Newsletter: Comps')
    comp_list.contacts.remove(*queryset)
  uncomp_contacts.short_description = (
    'Remove selected %(verbose_name_plural)s from comps'
  )

  def comp_contacts(self, request, queryset) -> None:
    """Adds Contacts to the Newsletter: Comp List."""
    comp_list = ContactList.objects.get(name='Newsletter: Comps')
    try:
      validate_contact_list_membership(
        sender=ContactList,
        instance=comp_list,
        action='pre_add',
        pk_set=set(queryset.values_list('pk', flat=True)),
      )
    except ValidationError as e:
      messages.error(request, e.messages[0])
    else:
      comp_list.contacts.add(*queryset)
  comp_contacts.short_description = (
    'Comp selected %(verbose_name_plural)s'
  )


# admin.py
# TODO: How to export StreetAddresses and PhoneNumbers?
from import_export import resources
from import_export.fields import Field
from import_export.widgets import ManyToManyWidget
class ContactResource(resources.ModelResource):
  """Import-Export Resource for Contacts."""

  # Use ContactList.name
  list_memberships = Field(
    attribute='list_memberships',
    column_name='list_memberships',
    widget=ManyToManyWidget(
      model=ContactList,
      separator=', ',
      field='name',
    ),
  )

  # Rename column names used for ID fields
  _id = Field(
    attribute='_id',
    column_name='contact_id',
  )
  id = Field(
    attribute='id',
    column_name='ctct_id',
  )
  user__id = Field(
    attribute='user__id',
    column_name='user_id',
  )
  customer__id = Field(
    attribute='customer__id',
    column_name='stripe_id',
  )

  class Meta:
    model = Contact
    fields = (
      'email',
      'honorific',
      'first_name',
      'last_name',
      'suffix',
      'job_title',
      'company_name',
      'created_at',
      'updated_at',
      'list_memberships',
    )
    export_order = fields

# admin.py
from import_export.formats import base_formats
from import_export.admin import ExportActionMixin
@admin.register(Contact)
class ContactAdmin(ExportActionMixin, admin.ModelAdmin):
  """Basic admin functionality for CTCT Contacts."""

  resource_classes = (
    ContactResource,
  )
  formats = (
    base_formats.CSV,
    base_formats.XLS,
    base_formats.XLSX,
    base_formats.JSON,
  )


